<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>spring4.3读书笔记2 | 博客</title>
    <meta name="description" content="zhangyongxin&#39;s blog">
    <link rel="icon" href="/zhangyongxin/favicon.ico">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    
    <link rel="preload" href="/zhangyongxin/assets/css/styles.74657ed2.css" as="style"><link rel="preload" href="/zhangyongxin/assets/js/app.74657ed2.js" as="script"><link rel="preload" href="/zhangyongxin/assets/css/styles.74657ed2.css" as="style"><link rel="preload" href="/zhangyongxin/assets/js/30.e5b2bc2d.js" as="script"><link rel="prefetch" href="/zhangyongxin/assets/css/1.styles.542cba6d.css"><link rel="prefetch" href="/zhangyongxin/assets/css/8.styles.4fe9bba1.css"><link rel="prefetch" href="/zhangyongxin/assets/js/1.542cba6d.js"><link rel="prefetch" href="/zhangyongxin/assets/js/10.64cadbad.js"><link rel="prefetch" href="/zhangyongxin/assets/js/11.9a671232.js"><link rel="prefetch" href="/zhangyongxin/assets/js/12.0e7cc131.js"><link rel="prefetch" href="/zhangyongxin/assets/js/13.609ed249.js"><link rel="prefetch" href="/zhangyongxin/assets/js/14.d6836a4c.js"><link rel="prefetch" href="/zhangyongxin/assets/js/15.7b74c80f.js"><link rel="prefetch" href="/zhangyongxin/assets/js/16.4895ae83.js"><link rel="prefetch" href="/zhangyongxin/assets/js/17.530d124f.js"><link rel="prefetch" href="/zhangyongxin/assets/js/18.b239cccc.js"><link rel="prefetch" href="/zhangyongxin/assets/js/19.b60b50ff.js"><link rel="prefetch" href="/zhangyongxin/assets/js/2.1e22d7f8.js"><link rel="prefetch" href="/zhangyongxin/assets/js/20.7b9d30ef.js"><link rel="prefetch" href="/zhangyongxin/assets/js/21.976a9872.js"><link rel="prefetch" href="/zhangyongxin/assets/js/22.21400a1f.js"><link rel="prefetch" href="/zhangyongxin/assets/js/23.43378c47.js"><link rel="prefetch" href="/zhangyongxin/assets/js/24.47ac6988.js"><link rel="prefetch" href="/zhangyongxin/assets/js/25.d0c557ef.js"><link rel="prefetch" href="/zhangyongxin/assets/js/26.e799ec6c.js"><link rel="prefetch" href="/zhangyongxin/assets/js/27.9e0b1fb5.js"><link rel="prefetch" href="/zhangyongxin/assets/js/28.981cd19c.js"><link rel="prefetch" href="/zhangyongxin/assets/js/29.75726558.js"><link rel="prefetch" href="/zhangyongxin/assets/js/3.5d4c971b.js"><link rel="prefetch" href="/zhangyongxin/assets/js/31.f35faab8.js"><link rel="prefetch" href="/zhangyongxin/assets/js/32.695115bf.js"><link rel="prefetch" href="/zhangyongxin/assets/js/33.d2d9144b.js"><link rel="prefetch" href="/zhangyongxin/assets/js/34.c16c5295.js"><link rel="prefetch" href="/zhangyongxin/assets/js/35.be01aa78.js"><link rel="prefetch" href="/zhangyongxin/assets/js/36.0a450691.js"><link rel="prefetch" href="/zhangyongxin/assets/js/37.cd1af253.js"><link rel="prefetch" href="/zhangyongxin/assets/js/38.1d1a4b90.js"><link rel="prefetch" href="/zhangyongxin/assets/js/4.7bab5812.js"><link rel="prefetch" href="/zhangyongxin/assets/js/5.7301bdbe.js"><link rel="prefetch" href="/zhangyongxin/assets/js/6.233a4d13.js"><link rel="prefetch" href="/zhangyongxin/assets/js/7.e8149bf7.js"><link rel="prefetch" href="/zhangyongxin/assets/js/8.4fe9bba1.js"><link rel="prefetch" href="/zhangyongxin/assets/js/9.08fcbe3b.js">
    <link rel="stylesheet" href="/zhangyongxin/assets/css/1.styles.542cba6d.css"><link rel="stylesheet" href="/zhangyongxin/assets/css/8.styles.4fe9bba1.css"><link rel="stylesheet" href="/zhangyongxin/assets/css/styles.74657ed2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="wrap"><div class="theme-container container no-sidebar"><header class="navbar"><div class="nav-header"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zhangyongxin/" class="home-link router-link-active"><img src="https://ae01.alicdn.com/kf/HTB1uzODadzvK1RkSnfo762MwVXai.png" class="logo"> <span class="site-name can-hide">
        博客
      </span></a> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zhangyongxin/" class="nav-link">首页</a></div><div class="nav-item"><a href="/zhangyongxin/tags/" class="nav-link">分类</a></div><div class="nav-item"><a href="/zhangyongxin/tools/toolCollections.html" class="nav-link">工具</a></div><div class="nav-item"><a href="/zhangyongxin/about/about.html" class="nav-link">About</a></div><div class="nav-item"><a href="https://github.com/xiaoxinshiwo" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div> <!----></nav> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zhangyongxin/" class="nav-link">首页</a></div><div class="nav-item"><a href="/zhangyongxin/tags/" class="nav-link">分类</a></div><div class="nav-item"><a href="/zhangyongxin/tools/toolCollections.html" class="nav-link">工具</a></div><div class="nav-item"><a href="/zhangyongxin/about/about.html" class="nav-link">About</a></div><div class="nav-item"><a href="https://github.com/xiaoxinshiwo" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div> <!----></nav> <!----></div> <div class="page-container"><div><div class="page card"><div class="content-header"><h1 class="page-title" style="color:#ac0b39;">
        spring4.3读书笔记2
      </h1> <span class="page-timestamp">2018-05-16 19:21:01</span></div> <div class="content"><ol start="21"><li>Fine-tuning annotation-based autowiring with qualifiers</li></ol> <blockquote><p>@Primary is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When more control over the selection process is required, Spring’s @Qualifier annotation can be used. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value:</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>public class MovieRecommender {

   @Autowired
   @Qualifier(&quot;main&quot;)
   private MovieCatalog movieCatalog;

   // ...
}
</code></pre></div> <p>The @Qualifier annotation can also be specified on individual constructor arguments or method parameters:</p> <div class="language- extra-class"><pre class="language-text"><code>public class MovieRecommender {

   private MovieCatalog movieCatalog;

   private CustomerPreferenceDao customerPreferenceDao;

   @Autowired
   public void prepare(@Qualifier(&quot;main&quot;)MovieCatalog movieCatalog,
           CustomerPreferenceDao customerPreferenceDao) {
       this.movieCatalog = movieCatalog;
       this.customerPreferenceDao = customerPreferenceDao;
   }

   // ...
}
</code></pre></div><ol start="22"><li>@Resource</li></ol> <blockquote><p>Spring also supports injection using the JSR-250 @Resource annotation on fields or bean property setter methods. This is a common pattern in Java EE 5 and 6, for example in JSF 1.2 managed beans or JAX-WS 2.0 endpoints. Spring supports this pattern for Spring-managed objects as well.
@Resource takes a name attribute, and by default Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in this example:</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name=&quot;myMovieFinder&quot;)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
</code></pre></div><p>If no name is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; in case of a setter method, it takes the bean property name. So the following example is going to have the bean with name &quot;movieFinder&quot; injected into its setter method:</p> <div class="language- extra-class"><pre class="language-text"><code>public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
</code></pre></div><ol start="23"><li>@Resource or @Autowired ？？？</li></ol> <blockquote><p>Letting qualifier values select against target bean names, within the type-matching candidates, doesn’t even require a @Qualifier annotation at the injection point. If there is no other resolution indicator (e.g. a qualifier or a primary marker), for a non-unique dependency situation, Spring will match the injection point name (i.e. field name or parameter name) against the target bean names and choose the same-named candidate, if any.
That said, if you intend to express annotation-driven injection by name, do not primarily use @Autowired, even if is capable of selecting by bean name among type-matching candidates. Instead, use the JSR-250 @Resource annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process. @Autowired has rather different semantics: After selecting candidate beans by type, the specified String qualifier value will be considered within those type-selected candidates only, e.g. matching an &quot;account&quot; qualifier against beans marked with the same qualifier label.
For beans that are themselves defined as a collection/map or array type, @Resource is a fine solution, referring to the specific collection or array bean by unique name. That said, as of 4.3, collection/map and array types can be matched through Spring’s @Autowired type matching algorithm as well, as long as the element type information is preserved in @Bean return type signatures or collection inheritance hierarchies. In this case, qualifier values can be used to select among same-typed collections, as outlined in the previous paragraph.
As of 4.3, @Autowired also considers self references for injection, i.e. references back to the bean that is currently injected. Note that self injection is a fallback; regular dependencies on other components always have precedence. In that sense, self references do not participate in regular candidate selection and are therefore in particular never primary; on the contrary, they always end up as lowest precedence. In practice, use self references as a last resort only, e.g. for calling other methods on the same instance through the bean’s transactional proxy: Consider factoring out the affected methods to a separate delegate bean in such a scenario. Alternatively, use @Resource which may obtain a proxy back to the current bean by its unique name.
@Autowired applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. By contrast, @Resource is supported only for fields and bean property setter methods with a single argument. As a consequence, stick with qualifiers if your injection target is a constructor or a multi-argument method.</p></blockquote> <ol start="24"><li>@Comment、@Controller、@Service、@Repository？？？</li></ol> <blockquote><p>The @Repository annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). Among the uses of this marker is the automatic translation of exceptions as described in Section 20.2.2, “Exception translation”.
Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases, for example, in the persistence, service, and presentation layers, respectively. Therefore, you can annotate your component classes with @Component, but by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. It is also possible that @Repository, @Service, and @Controller may carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated above, @Repository is already supported as a marker for automatic exception translation in your persistence layer.</p></blockquote> <p>&quot;Controller&quot; (e.g. a web controller)</p> <div class="language- extra-class"><pre class="language-text"><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any
	 */
	String value() default &quot;&quot;;

}
</code></pre></div><p>&quot;Business Service Facade&quot;</p> <div class="language- extra-class"><pre class="language-text"><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any
	 */
	String value() default &quot;&quot;;

}
</code></pre></div><p>DAO classes</p> <div class="language- extra-class"><pre class="language-text"><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Repository {

/**
 * The value may indicate a suggestion for a logical component name,
 * to be turned into a Spring bean in case of an autodetected component.
 * @return the suggested component name, if any
 */
String value() default &quot;&quot;;

}
</code></pre></div><ol start="25"><li>请注意，对静态@Bean方法的调用永远不会被容器拦截，即使在@Configuration类中也是如此（参见上文）。这是由于技术限制：CGLIB子类只能覆盖非静态方法。因此，直接调用另一个@Bean方法将具有标准Java语义，从而导致独立实例从工厂方法本身直接返回。 @Bean方法的Java语言可见性不会立即影响Spring容器中的结果bean定义。你可以自由地声明你的工厂方法，就像你在非@Configuration类中看到的那样，也可以在任何地方用静态方法。然而，@Configuration类中的常规@Bean方法需要被覆盖，即不能将它们声明为private或final。</li> <li>Basic concepts: @Bean and @Configuration</li></ol> <blockquote><p>The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.
The @Bean annotation is used to indicate that a method instantiates, configures and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s <beans></beans> XML configuration the @Bean annotation plays the same role as the <bean></bean> element. You can use @Bean annotated methods with any Spring @Component, however, they are most often used with @Configuration beans.
Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. Furthermore, @Configuration classes allow inter-bean dependencies to be defined by simply calling other @Bean methods in the same class. The simplest possible @Configuration class would read as follows:</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
</code></pre></div><p>The AppConfig class above would be equivalent to the following Spring <beans></beans> XML:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;beans&gt;
    &lt;bean id=&quot;myService&quot; class=&quot;com.acme.services.MyServiceImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre></div><ol start="27"><li>Full @Configuration vs 'lite' @Bean mode?</li></ol> <blockquote><p>When @Bean methods are declared within classes that are not annotated with @Configuration they are referred to as being processed in a 'lite' mode. Bean methods declared in a @Component or even in a plain old class will be considered 'lite', with a different primary purpose of the containing class and an @Bean method just being a sort of bonus there. For example, service components may expose management views to the container through an additional @Bean method on each applicable component class. In such scenarios, @Bean methods are a simple general-purpose factory method mechanism.
Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies. Instead, they operate on their containing component’s internal state and optionally on arguments that they may declare. Such an @Bean method should therefore not invoke other @Bean methods; each such method is literally just a factory method for a particular bean reference, without any special runtime semantics. The positive side-effect here is that no CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class design (i.e. the containing class may nevertheless be final etc).
In common scenarios, @Bean methods are to be declared within @Configuration classes, ensuring that 'full' mode is always used and that cross-method references will therefore get redirected to the container’s lifecycle management. This will prevent the same @Bean method from accidentally being invoked through a regular Java call which helps to reduce subtle bugs that can be hard to track down when operating in 'lite' mode.</p></blockquote> <blockquote><p>Remember that @Configuration classes are meta-annotated with @Component, so they are candidates for component-scanning! In the example above, assuming that AppConfig is declared within the com.acme package (or any package underneath), it will be picked up during the call to scan(), and upon refresh() all its @Bean methods will be processed and registered as bean definitions within the container.</p></blockquote> <ol start="28"><li>@Bean
@Bean需要被声明在@Configuration或者@Component …的类中，作用在方法上，@PostConstruct 等同于 @Bean(initMethod = &quot;init&quot;)的initMethod属性
@PreDestroy 等同于 @Bean(destoryMethod = &quot;close&quot;)的destoryMethod属性</li> <li>The following example shows a @Bean annotated method being called twice:</li></ol> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {
        return new ClientDaoImpl();
    }
}
</code></pre></div><blockquote><p>clientDao() has been called once in clientService1() and once in clientService2(). Since this method creates a new instance of ClientDaoImpl and returns it, you would normally expect having 2 instances (one for each service). That definitely would be problematic: in Spring, instantiated beans have a singleton scope by default. This is where the magic comes in: All @Configuration classes are subclassed at startup-time with CGLIB. In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance. Note that as of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB classes have been repackaged under org.springframework.cglib and included directly within the spring-core JAR.
所以还是单例？需要验证</p></blockquote> <ol start="30"><li>@Configuration</li></ol> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    @Autowired
    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);
}
</code></pre></div><blockquote><p>Constructor injection in @Configuration classes is only supported as of Spring Framework 4.3. Note also that there is no need to specify @Autowired if the target bean defines only one constructor; in the example above, @Autowired is not necessary on the RepositoryConfig constructor.</p></blockquote> <ol start="31"><li>@Lazy (for creation on first access instead of on startup)</li> <li>@Profile @Conditional</li></ol> <blockquote><p>It is often useful to conditionally enable or disable a complete @Configuration class, or even individual @Bean methods, based on some arbitrary system state. One common example of this is to use the @Profile annotation to activate beans only when a specific profile has been enabled in the Spring Environment
33.Combining Java and XML configuration
Spring’s @Configuration class support does not aim to be a 100% complete replacement for Spring XML. Some facilities such as Spring XML namespaces remain an ideal way to configure the container. In cases where XML is convenient or necessary, you have a choice: either instantiate the container in an &quot;XML-centric&quot; way using, for example, ClassPathXmlApplicationContext, or in a &quot;Java-centric&quot; fashion using AnnotationConfigApplicationContext and the @ImportResource annotation to import XML as needed.
33.@Configuration class-centric use of XML with @ImportResource
In applications where @Configuration classes are the primary mechanism for configuring the container, it will still likely be necessary to use at least some XML. In these scenarios, simply use @ImportResource and define only as much XML as is needed. Doing so achieves a &quot;Java-centric&quot; approach to configuring the container and keeps XML to a bare minimum.</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)
public class AppConfig {

   @Value(&quot;${jdbc.url}&quot;)
   private String url;

   @Value(&quot;${jdbc.username}&quot;)
   private String username;

   @Value(&quot;${jdbc.password}&quot;)
   private String password;

   @Bean
   public DataSource dataSource() {
       return new DriverManagerDataSource(url, username, password);
   }
}
</code></pre></div><p>properties-config.xml</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;beans&gt;
   &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;
&lt;/beans&gt;
jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
</code></pre></div><ol start="34"><li>@Profile
The @Profile annotation allows you to indicate that a component is eligible for registration when one or more specified profiles are active. Using our example above, we can rewrite the dataSource configuration as follows:</li></ol> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
@Profile(&quot;development&quot;)
public class StandaloneDataConfig {

   @Bean
   public DataSource dataSource() {
       return new EmbeddedDatabaseBuilder()
           .setType(EmbeddedDatabaseType.HSQL)
           .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
           .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)
           .build();
   }
}
</code></pre></div><blockquote><p>If a @Configuration class is marked with @Profile, all of the @Bean methods and @Import annotations associated with that class will be bypassed unless one or more of the specified profiles are active. If a @Component or @Configuration class is marked with @Profile({&quot;p1&quot;, &quot;p2&quot;}), that class will not be registered/processed unless profiles 'p1' and/or 'p2' have been activated. If a given profile is prefixed with the NOT operator (!), the annotated element will be registered if the profile is not active. For example, given @Profile({&quot;p1&quot;, &quot;!p2&quot;}), registration will occur if profile 'p1' is active or if profile 'p2' is not active.</p></blockquote> <ol start="35"><li>Activating a profile</li></ol> <blockquote><p>Now that we have updated our configuration, we still need to instruct Spring which profile is active. If we started our sample application right now, we would see a NoSuchBeanDefinitionException thrown, because the container could not find the Spring bean named dataSource.
Activating a profile can be done in several ways, but the most straightforward is to do it programmatically against the Environment API which is available via an ApplicationContext:</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
</code></pre></div><p>In addition, profiles may also be activated declaratively through the spring.profiles.active property which may be specified through system environment variables, JVM system properties, servlet context parameters in web.xml, or even as an entry in JNDI (see Section 7.13.2, “PropertySource abstraction”). In integration tests, active profiles can be declared via the @ActiveProfiles annotation in the spring-test module (see the section called “Context configuration with environment profiles”).
Note that profiles are not an &quot;either-or&quot; proposition; it is possible to activate multiple profiles at once. Programmatically, simply provide multiple profile names to the setActiveProfiles() method, which accepts String…​ varargs:</p> <div class="language- extra-class"><pre class="language-text"><code>ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;);
</code></pre></div><p>Declaratively, spring.profiles.active may accept a comma-separated list of profile names:</p> <div class="language- extra-class"><pre class="language-text"><code>-Dspring.profiles.active=&quot;profile1,profile2&quot;
</code></pre></div><ol start="36"><li>@PropertySource</li></ol> <blockquote><p>The @PropertySource annotation provides a convenient and declarative mechanism for adding a PropertySource to Spring’s Environment.
Given a file &quot;app.properties&quot; containing the key/value pair testbean.name=myTestBean, the following @Configuration class uses @PropertySource in such a way that a call to testBean.getName() will return &quot;myTestBean&quot;.
Any ${…​} placeholders present in a @PropertySource resource location will be resolved against the set of property sources already registered against the environment. For example:</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>@Configuration
@PropertySource(&quot;classpath:/com/${my.placeholder:default/path}/app.properties&quot;)
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    }
}
</code></pre></div><ol start="37"><li>Internationalization using MessageSource</li></ol> <blockquote><p>Spring provides two MessageSource implementations, ResourceBundleMessageSource and StaticMessageSource. Both implement HierarchicalMessageSource in order to do nested messaging. The StaticMessageSource is rarely used but provides programmatic ways to add messages to the source. The ResourceBundleMessageSource is shown in the following example:</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;beans&gt;
    &lt;bean id=&quot;messageSource&quot;
            class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;
        &lt;property name=&quot;basenames&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;format&lt;/value&gt;
                &lt;value&gt;exceptions&lt;/value&gt;
                &lt;value&gt;windows&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre></div><p>In the example it is assumed you have three resource bundles defined in your classpath called format, exceptions and windows. Any request to resolve a message will be handled in the JDK standard way of resolving messages through ResourceBundles. For the purposes of the example, assume the contents of two of the above resource bundle files are…​</p> <div class="language- extra-class"><pre class="language-text"><code># in format.properties
message=Alligators rock!
# in exceptions.properties
argument.required=The {0} argument is required.
</code></pre></div><p>A program to execute the MessageSource functionality is shown in the next example. Remember that all ApplicationContext implementations are also MessageSource implementations and so can be cast to the MessageSource interface.</p> <div class="language- extra-class"><pre class="language-text"><code>public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    String message = resources.getMessage(&quot;message&quot;, null, &quot;Default&quot;, null);
    System.out.println(message);
}
</code></pre></div><p>The resulting output from the above program will be…​
Alligators rock!</p> <blockquote><p>So to summarize, the MessageSource is defined in a file called beans.xml, which exists at the root of your classpath. The messageSource bean definition refers to a number of resource bundles through its basenames property. The three files that are passed in the list to the basenames property exist as files at the root of your classpath and are called format.properties, exceptions.properties, and windows.properties respectively.</p></blockquote> <blockquote><p>The next example shows arguments passed to the message lookup; these arguments will be converted into Strings and inserted into placeholders in the lookup message.
With regard to internationalization (i18n), Spring’s various MessageSource implementations follow the same locale resolution and fallback rules as the standard JDK ResourceBundle. In short, and continuing with the example messageSource defined previously, if you want to resolve messages against the British (en-GB) locale, you would create files called format_en_GB.properties, exceptions_en_GB.properties, and windows_en_GB.properties respectively.
Typically, locale resolution is managed by the surrounding environment of the application. In this example, the locale against which (British) messages will be resolved is specified manually.</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code># in exceptions_en_GB.properties
argument.required=Ebagum lad, the {0} argument is required, I say, required.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    String message = resources.getMessage(&quot;argument.required&quot;,
        new Object [] {&quot;userDao&quot;}, &quot;Required&quot;, Locale.UK);
    System.out.println(message);
}
</code></pre></div><p>The resulting output from the running of the above program will be…​
Ebagum lad, the 'userDao' argument is required, I say, required.
38. ApplicationEvent</p> <div class="language- extra-class"><pre class="language-text"><code>public class BlackListEvent extends ApplicationEvent {

    private final String address;
    private final String test;

    public BlackListEvent(Object source, String address, String test) {
        super(source);
        this.address = address;
        this.test = test;
    }

    // accessor and other methods...
}
</code></pre></div><p>To publish a custom ApplicationEvent, call the publishEvent() method on an ApplicationEventPublisher. Typically this is done by creating a class that implements ApplicationEventPublisherAware and registering it as a Spring bean. The following example demonstrates such a class:</p> <div class="language- extra-class"><pre class="language-text"><code>public class EmailService implements ApplicationEventPublisherAware {

    private List&lt;String&gt; blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List&lt;String&gt; blackList) {
        this.blackList = blackList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent event = new BlackListEvent(this, address, text);
            publisher.publishEvent(event);
            return;
        }
        // send email...
    }
}
</code></pre></div><p>At configuration time, the Spring container will detect that EmailService implements ApplicationEventPublisherAware and will automatically call setApplicationEventPublisher(). In reality, the parameter passed in will be the Spring container itself; you’re simply interacting with the application context via its ApplicationEventPublisher interface.
To receive the custom ApplicationEvent, create a class that implements ApplicationListener and register it as a Spring bean. The following example demonstrates such a class:</p> <div class="language- extra-class"><pre class="language-text"><code>public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
</code></pre></div><p>Notice that ApplicationListener is generically parameterized with the type of your custom event, BlackListEvent. This means that the onApplicationEvent() method can remain type-safe, avoiding any need for downcasting. You may register as many event listeners as you wish, but note that by default event listeners receive events synchronously. This means the publishEvent() method blocks until all listeners have finished processing the event. One advantage of this synchronous and single-threaded approach is that when a listener receives an event, it operates inside the transaction context of the publisher if a transaction context is available. If another strategy for event publication becomes necessary, refer to the javadoc for Spring’s ApplicationEventMulticaster interface.
The following example shows the bean definitions used to register and configure each of the classes above:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;bean id=&quot;emailService&quot; class=&quot;example.EmailService&quot;&gt;
    &lt;property name=&quot;blackList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;known.spammer@example.org&lt;/value&gt;
            &lt;value&gt;known.hacker@example.org&lt;/value&gt;
            &lt;value&gt;john.doe@example.org&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;blackListNotifier&quot; class=&quot;example.BlackListNotifier&quot;&gt;
    &lt;property name=&quot;notificationAddress&quot; value=&quot;blacklist@example.org&quot;/&gt;
&lt;/bean&gt;
</code></pre></div><p>Putting it all together, when the sendEmail() method of the emailService bean is called, if there are any emails that should be blacklisted, a custom event of type BlackListEvent is published. The blackListNotifier bean is registered as an ApplicationListener and thus receives the BlackListEvent, at which point it can notify appropriate parties.
Spring’s eventing mechanism is designed for simple communication between Spring beans within the same application context. However, for more sophisticated enterprise integration needs, the separately-maintained Spring Integration project provides complete support for building lightweight, pattern-oriented, event-driven architectures that build upon the well-known Spring programming model.</p> <p>Annotation-based event listeners
As of Spring 4.2, an event listener can be registered on any public method of a managed bean via the EventListener annotation. The BlackListNotifier can be rewritten as follows:</p> <div class="language- extra-class"><pre class="language-text"><code>public class BlackListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlackListEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
</code></pre></div><p>As you can see above, the method signature once again declares the event type it listens to, but this time with a flexible name and without implementing a specific listener interface. The event type can also be narrowed through generics as long as the actual event type resolves your generic parameter in its implementation hierarchy.
If your method should listen to several events or if you want to define it with no parameter at all, the event type(s) can also be specified on the annotation itself:</p> <div class="language- extra-class"><pre class="language-text"><code>@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    ...
}
It is also possible to add additional runtime filtering via the condition attribute of the annotation that defines a SpEL expression that should match to actually invoke the method for a particular event.

For instance, our notifier can be rewritten to be only invoked if the test attribute of the event is equal to foo:

@EventListener(condition = &quot;#blEvent.test == 'foo'&quot;)
public void processBlackListEvent(BlackListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}
</code></pre></div><ol start="39"><li>ApplicationContext instantiation for web applications
You can create ApplicationContext instances declaratively by using, for example, a ContextLoader. Of course you can also create ApplicationContext instances programmatically by using one of the ApplicationContext implementations.
You can register an ApplicationContext using the ContextLoaderListener as follows:</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre></div><p>40.BeanFactory or ApplicationContext?
Use an ApplicationContext unless you have a good reason for not doing so.
Because the ApplicationContext includes all functionality of the BeanFactory, it is generally recommended over the BeanFactory, except for a few situations such as in embedded applications running on resource-constrained devices where memory consumption might be critical and a few extra kilobytes might make a difference. However, for most typical enterprise applications and systems, the ApplicationContext is what you will want to use. Spring makes heavy use of the BeanPostProcessor extension point (to effect proxying and so on). If you use only a plain BeanFactory, a fair amount of support such as transactions and AOP will not take effect, at least not without some extra steps on your part. This situation could be confusing because nothing is actually wrong with the configuration.
The following table lists features provided by the BeanFactory and ApplicationContext interfaces and implementations.</p> <table><thead><tr><th style="text-align:left">Feature</th> <th style="text-align:left">BeanFactory</th> <th style="text-align:left">ApplicationContext</th></tr></thead> <tbody><tr><td style="text-align:left">Bean instantiation/wiring</td> <td style="text-align:left">Yes</td> <td style="text-align:left">Yes</td></tr> <tr><td style="text-align:left">Automatic BeanPostProcessor registration</td> <td style="text-align:left">No</td> <td style="text-align:left">Yes</td></tr> <tr><td style="text-align:left">Automatic BeanFactoryPostProcessor registration</td> <td style="text-align:left">No</td> <td style="text-align:left">Yes</td></tr> <tr><td style="text-align:left">Convenient MessageSource access (for i18n)</td> <td style="text-align:left">No</td> <td style="text-align:left">Yes</td></tr> <tr><td style="text-align:left">ApplicationEvent publication</td> <td style="text-align:left">No</td> <td style="text-align:left">Yes</td></tr></tbody></table></div> <!----> <div class="content page-nav"><p class="inner"><span class="prev">
          ← <a href="/zhangyongxin/blog/springNotes3.html" class="prev">
            spring4.3读书笔记3
          </a></span> <span class="next"><a href="/zhangyongxin/blog/interestingThoughts/interestingThoughts.html">
            有趣的想法
          </a> →
        </span></p></div></div> <div id="comment-container"><div class="gt-container"><div class="gt-initing"><i class="gt-loader"></i> <p class="gt-initing-text">Gitalking ...</p></div> <!----> <!----> <div><div class="gt-header"><a class="gt-avatar-github"><span class="gt-ico gt-ico-github"><span class="gt-svg"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64 524C64 719.602 189.356 885.926 364.113 947.017 387.65799 953 384 936.115 384 924.767L384 847.107C248.118 863.007 242.674 773.052 233.5 758.001 215 726.501 171.5 718.501 184.5 703.501 215.5 687.501 247 707.501 283.5 761.501 309.956 800.642 361.366 794.075 387.658 787.497 393.403 763.997 405.637 743.042 422.353 726.638 281.774 701.609 223 615.67 223 513.5 223 464.053 239.322 418.406 271.465 381.627 251.142 320.928 273.421 269.19 276.337 261.415 334.458 256.131 394.888 302.993 399.549 306.685 432.663 297.835 470.341 293 512.5 293 554.924 293 592.81 297.896 626.075 306.853 637.426 298.219 693.46 258.054 747.5 262.966 750.382 270.652 772.185 321.292 753.058 381.083 785.516 417.956 802 463.809 802 513.5 802 615.874 742.99 701.953 601.803 726.786 625.381 750.003 640 782.295 640 818.008L640 930.653C640.752 939.626 640 948.664978 655.086 948.665 832.344 888.962 960 721.389 960 524 960 276.576 759.424 76 512 76 264.577 76 64 276.576 64 524Z"></path>
</svg>
</span> <!----></span></a> <div class="gt-header-comment"><textarea placeholder="Leave a comment" class="gt-header-textarea"></textarea> <div class="gt-header-preview markdown-body hide"></div> <div class="gt-header-controls"><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" class="gt-header-controls-tip"><span class="gt-ico gt-ico-tip"><span class="gt-svg"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 366.949535c-16.065554 0-29.982212 13.405016-29.982212 29.879884l0 359.070251c0 16.167882 13.405016 29.879884 29.982212 29.879884 15.963226 0 29.879884-13.405016 29.879884-29.879884L541.879884 396.829419C541.879884 380.763865 528.474868 366.949535 512 366.949535L512 366.949535z"
    p-id="3083"></path>
  <path d="M482.017788 287.645048c0-7.776956 3.274508-15.553912 8.80024-21.181973 5.525732-5.525732 13.302688-8.80024 21.181973-8.80024 7.776956 0 15.553912 3.274508 21.079644 8.80024 5.525732 5.62806 8.80024 13.405016 8.80024 21.181973 0 7.776956-3.274508 15.656241-8.80024 21.181973-5.525732 5.525732-13.405016 8.697911-21.079644 8.697911-7.879285 0-15.656241-3.274508-21.181973-8.697911C485.292295 303.301289 482.017788 295.524333 482.017788 287.645048L482.017788 287.645048z"
    p-id="3084"></path>
  <path d="M512 946.844409c-239.8577 0-434.895573-195.037873-434.895573-434.895573 0-239.8577 195.037873-434.895573 434.895573-434.895573 239.755371 0 434.895573 195.037873 434.895573 434.895573C946.895573 751.806535 751.755371 946.844409 512 946.844409zM512 126.17088c-212.740682 0-385.880284 173.037274-385.880284 385.777955 0 212.740682 173.037274 385.777955 385.880284 385.777955 212.740682 0 385.777955-173.037274 385.777955-385.777955C897.777955 299.208154 724.740682 126.17088 512 126.17088z"
    p-id="3085"></path>
</svg>
</span> <span class="gt-ico-text">Markdown is supported</span></span></a> <!----> <button class="gt-btn gt-btn-preview"><span class="gt-btn-text">Preview</span> <!----></button> <button class="gt-btn gt-btn-login"><span class="gt-btn-text">Login with GitHub</span> <!----></button></div></div></div> <div class="gt-comments"><span></span> <p class="gt-comments-null">
                Be the first guy leaving a comment!
            </p> <!----></div></div></div></div></div> <!----></div> <div class="tool-group"><!----></div></div> <!----></div> <div class="background-mask" style="background:url(&quot;https://s1.ax1x.com/2018/12/26/F2wEkD.jpg&quot;) no-repeat fixed;"></div></div></div>
    <script src="/zhangyongxin/assets/js/30.e5b2bc2d.js" defer></script><script src="/zhangyongxin/assets/js/app.74657ed2.js" defer></script>
  </body>
</html>
